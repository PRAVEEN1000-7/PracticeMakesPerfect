# Day 25 - Iterators & Generators

*Iterators & Generators*

## Problems Completed âœ…
- **Custom Iterator** - Build a custom iterator (EvenNumbers up to N)
- **Generator Function** - Write a generator function for Fibonacci numbers
- **Performance Comparison** - Compare generator vs list performance with large data

## What I Learned
- Custom iterator implementation with `__iter__` and `__next__`
- Generator functions with `yield` keyword
- Memory efficiency of generators vs lists
- Iterator protocol and lazy evaluation
- Performance analysis of different data structures

## Solution Approaches Implemented
1. **Custom Iterator:** Class-based iterator with state management
2. **Generator Function:** Function-based generator with yield
3. **Performance Testing:** Memory and speed comparison

## Key Concepts
- **Iterator Protocol:** `__iter__` and `__next__` methods
- **Generator Functions:** `yield` for lazy evaluation
- **Memory Efficiency:** Generators use less memory than lists
- **Lazy Evaluation:** Values computed on-demand

## Code Structure
```python
# Iterator: Class with __iter__ and __next__ methods
# Generator: Function with yield for memory-efficient iteration
```

## Files
- `iterator_EvenNumberUptoN.py`
- `generator_Fibonacci.py`
- `list_vs_generator.py`

---
**Progress:** 56 problems completed